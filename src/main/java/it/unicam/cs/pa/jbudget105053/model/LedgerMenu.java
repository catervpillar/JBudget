package it.unicam.cs.pa.jbudget105053.model;

import java.util.LinkedList;
import java.util.List;
import java.util.Objects;
import java.util.function.Predicate;
import java.util.stream.Collectors;

/**
 * This class implements the interface {@link Ledger} and has the responsibility to manage all
 * data of the application.
 * It has the responsibility to create and remove accounts, create and remove tags and
 * add and remove transactions.
 * It is also possible to view the entire list of stored accounts, tags, transactions and movements
 * as well as a list of all transactions and accounts that satisfy a particular predicate.
 *
 * @author Tommaso Catervi
 */
public class LedgerMenu implements Ledger {
    private final List<Account> accountsList = new LinkedList<>();
    private final List<Tag> tagsList = new LinkedList<>();
    private final List<Transaction> transactionsList = new LinkedList<>();
    private final List<Movement> movementsList = new LinkedList<>();

    /**
     * Allows to create and add a new {@link Account} to the {@code accountList}.
     * The value of the {@code ID} field is generated by the class {@link Indexer}.
     *
     * @param accountType    the value used to set the {@code accountType} field in the {@link Account}.
     * @param name           the value used to set the {@code name} field in the {@link Account}.
     * @param initialBalance the value used to set the {@code initialBalance} field in the {@link Account}.
     */
    @Override
    public void addAccount(AccountType accountType, String name, double initialBalance) {
        Account a = new BasicAccount(Indexer.getInstance().generateAccountID(), accountType, name, initialBalance);
        if (accountsList.contains(a))
            throw new IllegalArgumentException(Account.MESSAGE_ACCOUNT_ALREADY_EXISTS);
        accountsList.add(a);
    }

    /**
     * Allows to create and add a new {@link Account} to the {@code accountList} without automatically
     * generating its ID.
     *
     * @param ID             the value used to set the {@code ID} field in the {@link Account}.
     * @param accountType    the value used to set the {@code accountType} field in the {@link Account}.
     * @param name           the value used to set the {@code name} field in the {@link Account}.
     * @param initialBalance the value used to set the {@code initialBalance} field in the {@link Account}.
     */
    @Override
    public void addAccountWithID(int ID, AccountType accountType, String name, double initialBalance) {
        Account a = new BasicAccount(ID, accountType, name, initialBalance);
        if (accountsList.contains(a))
            throw new IllegalArgumentException(Account.MESSAGE_ACCOUNT_ALREADY_EXISTS);
        accountsList.add(a);
        Indexer.getInstance().fixAccountID(accountsList);
    }

    /**
     * Allows to modify the given {@link Account} with the given parameters.
     *
     * @param a              the {@link Account} to modify.
     * @param accountType    the new {@link AccountType} to set.
     * @param name           the new name to set.
     * @param initialBalance the new initial balance to set.
     */
    @Override
    public void modifyAccount(Account a, AccountType accountType, String name, double initialBalance) {
        a.setAccountType(accountType);
        a.setName(name);
        a.setInitialBalance(initialBalance);
    }

    /**
     * Allows to remove an {@link Account} from the {@code accountList} as long as
     * the given parameter is not null and is contained in the {@code accountList}.
     * When an {@link Account} is removed, all movements associated with that
     * {@link Account} are removed from the {@code movementsList} and from the movements
     * list of all transactions. All transactions resulting with zero movements after
     * this computation are removed from the transactions list.
     *
     * @param account the {@link Account} to be removed.
     */
    @Override
    public void removeAccount(Account account) {
        if (!accountsList.contains(controlAccount(account)))
            throw new IllegalArgumentException(Account.MESSAGE_ACCOUNT_DOES_NOT_EXIST);
        movementsList.removeIf(m -> m.getAccount().equals(account));
        transactionsList.forEach(t -> t.getMovements().removeIf(m -> m.getAccount().equals(account)));
        transactionsList.removeIf(t -> t.getMovements().isEmpty());
        accountsList.removeIf(a -> a.equals(account));
    }

    /**
     * Controls that the given {@link Account} is not null.
     *
     * @param account the value to control.
     * @return the controlled {@link Account}.
     */
    private Account controlAccount(Account account) {
        if (Objects.isNull(account))
            throw new NullPointerException(Account.MESSAGE_NULL_ACCOUNT);
        return account;
    }

    /**
     * Getter method for the list {@code accountList} which contains all the
     * accounts associated with this {@link LedgerMenu}.
     *
     * @return the list of all the accounts of the {@link LedgerMenu}.
     */
    @Override
    public List<Account> getAccounts() {
        return accountsList;
    }

    /**
     * Returns the list {@code accountList} after filtering it according to the
     * {@link Predicate} {@code p}.
     *
     * @return the filtered {@code accountList}.
     */
    @Override
    public List<Account> getAccounts(Predicate<Account> p) {
        return accountsList.stream().filter(p).collect(Collectors.toList());
    }

    /**
     * Allows to add a new {@link Transaction} to the {@code transactionList} as long as
     * the given parameter is not null and does not already exist in the {@code transactionList}.
     * When a {@link Transaction} is added, all its movements are added to the {@link Account}
     * they are associated with and to the {@code movementsList}.
     *
     * @param transaction the {@link Transaction} to add.
     */
    @Override
    public void addTransaction(Transaction transaction) {
        if (transactionsList.contains(controlTransaction(transaction)))
            throw new IllegalArgumentException(Transaction.MESSAGE_TRANSACTION_ALREADY_EXISTS);
        movementsList.addAll(transaction.getMovements());
        Indexer.getInstance().fixMovementID(movementsList);
        transactionsList.add(transaction);
        Indexer.getInstance().fixTransactionID(transactionsList);
        transaction.getMovements().forEach(mov -> mov.getAccount().addMovement(mov));
    }

    /**
     * Allows to remove a {@link Transaction} from the {@code transactionList} as long as
     * the given parameter is not null and is contained in the {@code transactionList}.
     * When a {@link Transaction} is removed from the {@code transactionList}, each
     * {@link Movement} associated with that {@link Transaction} is removed from the
     * {@code movementList} of the accounts it is associated with.
     * Also each {@link Movement} in the {@code movementsList} associated with that
     * {@link Transaction} is removed.
     *
     * @param t the {@link Transaction} to remove.
     */
    @Override
    public void removeTransaction(Transaction t) {
        if (!transactionsList.contains(controlTransaction(t)))
            throw new IllegalArgumentException(Transaction.MESSAGE_TRANSACTION_DOES_NOT_EXIST);
        accountsList.forEach(a -> a.getMovementsList().removeIf(m -> m.getTransaction().equals(t)));
        movementsList.removeIf(m -> m.getTransaction().equals(t));
        transactionsList.remove(t);
    }

    /**
     * Controls that the given {@link Transaction} is not null.
     *
     * @param transaction the value to control.
     * @return the controlled {@link Transaction}.
     */
    private Transaction controlTransaction(Transaction transaction) {
        if (transaction == null)
            throw new NullPointerException(Transaction.MESSAGE_NULL_TRANSACTION);
        return transaction;
    }

    /**
     * Getter method for the list {@code transactionList} which contains all the
     * transactions associated with this {@link LedgerMenu}.
     *
     * @return the list of all transactions of this {@link LedgerMenu}.
     */
    @Override
    public List<Transaction> getTransactions() {
        return transactionsList;
    }

    /**
     * Returns the list {@code transactionList} after filtering it according to
     * the {@link Predicate} {@code p}.
     *
     * @return the filtered {@code transactionList}.
     */
    @Override
    public List<Transaction> getTransactions(Predicate<Transaction> p) {
        return transactionsList.stream().filter(p).collect(Collectors.toList());
    }

    /**
     * Getter method for the list {@code movementsList} which contains all the
     * movements associated with this {@link LedgerMenu}.
     *
     * @return the list of all movements of this {@link LedgerMenu}.
     */
    @Override
    public List<Movement> getMovements() {
        return movementsList;
    }

    /**
     * Getter method for the list {@code tagList} which contains all the tags
     * associated with this {@link LedgerMenu}.
     *
     * @return the list of all tags of this {@link LedgerMenu}.
     */
    @Override
    public List<Tag> getTags() {
        return tagsList;
    }

    /**
     * Allows to create and add a new {@link Tag} to the {@code tagList} and returns it.
     * The value of the {@code ID} field is generated by the class {@link Indexer}.
     *
     * @param name        the value used to set the {@code name} field in the {@link Tag}.
     * @param description the value used to set the {@code description} field in the {@link Tag}.
     */
    @Override
    public void addTag(String name, String description) {
        BasicTag t = new BasicTag(Indexer.getInstance().generateTagID(), name, description);
        if (tagsList.contains(t))
            throw new IllegalArgumentException(Tag.MESSAGE_TAG_ALREADY_EXISTS);
        tagsList.add(t);
    }

    /**
     * Allows to create and add a new {@link Tag} to the {@code tagList} without automatically
     * generating its ID.
     *
     * @param ID          the value used to set the {@code ID} field in the {@link Tag}.
     * @param name        the value used to set the {@code name} field in the {@link Tag}.
     * @param description the value used to set the {@code description} field in the {@link Tag}.
     */
    @Override
    public void addTagWithID(int ID, String name, String description) {
        BasicTag t = new BasicTag(ID, name, description);
        if (tagsList.contains(t))
            throw new IllegalArgumentException(Tag.MESSAGE_TAG_ALREADY_EXISTS);
        tagsList.add(t);
        Indexer.getInstance().fixTagID(tagsList);
    }

    /**
     * Allows to modify the given {@link Tag} with the given parameters.
     *
     * @param t           the {@link Tag} to modify.
     * @param name        the new name to set.
     * @param description the new description to set.
     */
    @Override
    public void modifyTag(Tag t, String name, String description) {
        t.setName(name);
        t.setDescription(description);
    }

    /**
     * Allows to remove a {@link Tag} from the {@code tagList} as long as the given parameter
     * is not null and is contained in the {@code tagList}.
     * The given {@link Tag} is also removed from all transactions and movements.
     *
     * @param tag the {@link Tag} to remove.
     */
    @Override
    public void removeTag(Tag tag) {
        if (!tagsList.contains(controlTag(tag)))
            throw new IllegalArgumentException(Tag.MESSAGE_TAG_DOES_NOT_EXIST);
        tagsList.remove(tag);
        transactionsList.forEach(t -> {
            if (t.getTag().contains(tag)) t.removeTag(tag);
        });
        movementsList.forEach(m -> {
            if (m.getTag().contains(tag)) m.removeTag(tag);
        });
    }

    /**
     * Controls that the given {@link Tag} is not null.
     *
     * @param t the {@link Tag} to control.
     */
    private Tag controlTag(Tag t) {
        if (t == null)
            throw new NullPointerException(Tag.MESSAGE_NULL_TAG);
        return t;
    }

    /**
     * Resets this ledger by emptying all its lists and resetting the ID generators
     * of the class {@link Indexer}.
     */
    @Override
    public void resetLedger() {
        accountsList.clear();
        tagsList.clear();
        transactionsList.clear();
        movementsList.clear();
        Indexer.getInstance().resetAll();
    }
}
